---
title: "scorepossibleparents"
author: "Shengtong"
date: "2018-11-06"
output: workflowr::wflow_html
---

scorepossibleparents 
DAGcorescore is a key function!! 

```{r, echo=T}
DAGcorescore=function(j,parentnodes,n){

  lp<-length(parentnodes) #number of parents
  awpNd2<-(awpN-n+lp+1)/2  #  what is awpN=107? 
  
  A<-TN[j,j]
  
  switch(as.character(lp),
         "0"={# just a single term if no parents
           corescore <- scoreconstvec[lp+1] -awpNd2*log(A)
         },
         
         "1"={# no need for matrices
           D<-TN[parentnodes,parentnodes]
           logdetD<-log(D)
           B<-TN[j,parentnodes]
           logdetpart2<-log(A-B^2/D)
           corescore <- scoreconstvec[lp+1]-awpNd2*logdetpart2 - logdetD/2
         },
         
         "2"={# can do matrix determinant and inverse explicitly
           # but this is numerically unstable for large matrices!
		D<-TN[parentnodes,parentnodes]
		detD<-D[1,1]*D[2,2]-D[1,2]^2 #using symmetry of D
		logdetD<-log(detD)
		B<-TN[j,parentnodes]
		logdetpart2<-log(A-(D[2,2]*B[1]^2+D[1,1]*B[2]^2-2*D[1,2]*B[1]*B[2])/detD) #also using symmetry of D
		corescore <- scoreconstvec[lp+1]-awpNd2*logdetpart2 - logdetD/2
         },
         
         "3"={# can still do matrix determinants efficiently so we use other approach
           # but the explicit formula is numerically unstable for large matrices!
           D<-TN[parentnodes,parentnodes]
           detD<-detthreebythree(D)
           logdetD<-log(detD)
           B<-TN[j,parentnodes]
           logdetpart2<-log(detthreebythree(D-(B)%*%t(B)/A))+log(A)-logdetD
           corescore <- scoreconstvec[lp+1]-awpNd2*logdetpart2 - logdetD/2
         },
         
  {# otherwise we use cholesky decomposition to perform both
    D<-as.matrix(TN[parentnodes,parentnodes])
    choltemp<-chol(D)
    logdetD<-2*log(prod(choltemp[(lp+1)*c(0:(lp-1))+1]))
    B<-TN[j,parentnodes]
    logdetpart2<-log(A-sum(backsolve(choltemp,B,transpose=TRUE)^2))
    corescore <- scoreconstvec[lp+1]-awpNd2*logdetpart2 - logdetD/2
  })
  
}
```

```{r, echo=T}
TableDAGscore=function(parentrows, j, n){
	nrows<-nrow(parentrows)
	P_local <- numeric(nrows)   
   
	for (i in 1:nrows)  {
		parentnodes <- parentrows[i,which(parentrows[i,]>0)] # for every row, extract numeric values as parents 
		P_local[i]<-DAGcorescore(j,parentnodes,n)  # DAGcorescore is in numedgescore.R 
	}

return(P_local)
}
```


```{r, echo=T}
scorepossibleparents=function(parenttable,n){

  listy<-vector("list",n)

  for (j in 1:n){
    scoretemp<-TableDAGscore(parenttable[[j]], j, n)      # TableDAGscore is in scorefns.R 
    listy[[j]] <- as.matrix(scoretemp)
  }  

return(listy)

}
```

```{r, echo=T, eval=F}
# first run listpossibleparents 
parenttable<-listpossibleparents(maxparents,c(1:n))
scoretable<-scorepossibleparents(parenttable,n) 
```
